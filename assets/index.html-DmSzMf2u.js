import{_ as p,r as l,c as d,e as s,d as a,b as e,a as h,o as r}from"./app-D2B0C_7K.js";const c={};function k(o,i){const n=l("Icon"),t=l("RepoCard");return r(),d("div",null,[i[0]||(i[0]=s("h2",{id:"安装jclasslib",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#安装jclasslib"},[s("span",null,"安装jclasslib")])],-1)),i[1]||(i[1]=s("p",null,"字节码文件是二进制文件，直接用记事本这类的工具查看肯定是乱码的，因此如果要查看字节码文件就需要一款专门的工具",-1)),i[2]||(i[2]=s("p",null,[a("这里推荐使用"),s("code",null,"jclasslib"),a("来查看字节码文件")],-1)),e(n,{name:"mdi:github",color:"currentColor",size:"1em"}),i[3]||(i[3]=a("Github仓库传送门")),e(t,{repo:"ingokegel/jclasslib"}),i[4]||(i[4]=h(`<h2 id="组成" tabindex="-1"><a class="header-anchor" href="#组成"><span>组成</span></a></h2><ol><li>基础信息</li></ol><p>魔数、字节码文件对应的Java版本号、访问标识(public、private等)、父类和接口</p><ol start="2"><li>常量池</li></ol><p>字符串常量、类或者接口名、字段名</p><ol start="3"><li>字段</li></ol><p>比如有如下Java代码：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> a1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>那么<code>a1</code>这个变量的变量名和访问标识都在<code>字段</code>这个部分</p><ol start="4"><li>方法</li></ol><p>当前类或接口声明的方法信息</p><ol start="5"><li>属性</li></ol><p>类的属性，比如源码的文件名，内部的列表等</p><h3 id="魔数" tabindex="-1"><a class="header-anchor" href="#魔数"><span>魔数</span></a></h3><p><img src="https://cdn.jsdelivr.net/gh/hxywd666/BlogResource/images/jvm1.png" alt=""></p><p>可以看到，上图中画红色框框的部分，在每个字节码文件的十六进制表示中都会存在，这就是魔数，它的作用是标识这个文件是一个字节码文件，而不是其他文件</p><p>Java虚拟机会校验文件的魔数是否正确，如果不正确，虚拟机就会抛出对应的错误</p><h3 id="常量池" tabindex="-1"><a class="header-anchor" href="#常量池"><span>常量池</span></a></h3><p>字节码文件中常量池的作用：避免相同的内容重复定义，节省空间</p><p>比如在代码中，定义了如下两个变量：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> str1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">123</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> str2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">123</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>那么在字节码文件中，<code>str1</code>和<code>str2</code>的值都是<code>123</code>，那么在常量池中，只需要保存一份<code>123</code>，然后<code>str1</code>和<code>str2</code>都指向这个<code>123</code>，这样就避免了重复定义</p><p>常量池中的数据都有一个编号，这个编号从1开始。在字段或者字节码指令中通过编号可以快速的找到这个字符串</p><p>字节码指令中通过编号引用到常量池的过程称之为<mark>符号引用</mark></p><h3 id="字段" tabindex="-1"><a class="header-anchor" href="#字段"><span>字段</span></a></h3><p>字段中存放的是当前类或接口声明的字段信息。</p><p>如下图中，定义了两个字段a1和a2，这两个字段就会出现在字段这部分内容中。同时还包含字段的名字、描述符（字段的类型）、访问标识(public/private static final等)</p><p><img src="https://cdn.jsdelivr.net/gh/hxywd666/BlogResource/images/jvm2.png" alt=""></p><h3 id="方法" tabindex="-1"><a class="header-anchor" href="#方法"><span>方法</span></a></h3><p>字节码中的方法区域是存放<mark>字节码指令</mark>的核心位置，字节码指令的内容存放在方法的Code属性中。通过分析方法的字节码指令，可以清楚地了解一个方法到底是如何执行的。先来看如下案例：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> j</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码编译成字节码指令之后是如下内容：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>iconst_0</span></span>
<span class="line"><span>istore 1</span></span>
<span class="line"><span>iload_1</span></span>
<span class="line"><span>iconst_1</span></span>
<span class="line"><span>iadd</span></span>
<span class="line"><span>istore 2</span></span>
<span class="line"><span>return</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要理解这段字节码指令是如何执行的，我们需要先理解两块内存区域：<mark>操作数栈</mark>和<mark>局部变量表</mark></p><ul><li><strong>操作数栈</strong>是用来存放临时数据的内容，是一个栈式的结构，先进后出</li><li><strong>局部变量</strong>表是存放方法中的局部变量，包含方法的参数、方法中定义的局部变量，在编译期就已经可以确定方法有多少个局部变量</li></ul><p>明白了上面的概念之后，我们按照从上往下的顺序来逐句解释一下字节码指令：</p><ol><li><p><code>iconst_0</code>，将常量0放入操作数栈。此时栈上只有0</p></li><li><p><code>istore_1</code>会从操作数栈中，将栈顶的元素弹出来，此时0会被弹出，放入局部变量表的1号位置(局部变量表中的1号位置，在编译时就已经确定是局部变量i使用的位置)，完成了对局部变量i的赋值操作</p></li><li><p><code>iload_1</code>将局部变量表1号位置的数据放入操作数栈中，此时栈中又会放入0</p></li><li><p><code>iconst_1</code>会将常量1放入操作数栈中</p></li><li><p><code>iadd</code>会将操作数栈顶部的两个数据相加，现在操作数栈上有两个数0和1，相加之后结果为1放入操作数栈中，此时栈上只有一个数也就是相加的结果1</p></li><li><p><code>istore_2</code>从操作数栈中将1弹出，并放入局部变量表的2号位置，2号位置是j在使用。完成了对局部变量j的赋值操作</p></li><li><p><code>return</code>语句执行，方法结束并返回</p></li></ol><h2 id="类的生命周期" tabindex="-1"><a class="header-anchor" href="#类的生命周期"><span>类的生命周期</span></a></h2><p>类的生命周期描述了一个类加载、使用、卸载的整个过程。整体可以分为：</p><ul><li>加载</li><li>连接，其中又分为验证、准备、解析三个子阶段</li><li>初始化</li><li>使用</li><li>卸载</li></ul><h3 id="加载阶段" tabindex="-1"><a class="header-anchor" href="#加载阶段"><span>加载阶段</span></a></h3><ol><li>加载阶段第一步是类加载器根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息，程序员可以使用Java代码拓展的不同的渠道</li></ol><ul><li>从本地磁盘上获取文件</li><li>运行时通过动态代理生成，比如Spring框架</li><li>Applet技术通过网络获取字节码文件</li></ul><ol start="2"><li><p>类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中，方法区中生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息</p></li><li><p>Java虚拟机同时会在堆上生成与方法区中数据类似的java.lang.Class对象，作用是在Java代码中去获取类的信息以及存储静态字段的数据(JDK8及之后)</p></li></ol><h3 id="连接阶段" tabindex="-1"><a class="header-anchor" href="#连接阶段"><span>连接阶段</span></a></h3><p>连接阶段分为三个子阶段:</p><ol><li>验证，验证内容是否满足Java虚拟机规范</li><li>准备，给静态变量赋初值</li><li>解析，将常量池中的符号引用替换成指向内存的直接引用</li></ol><ul><li><strong>验证</strong></li></ul><p>验证的主要目的是检测Java字节码文件是否遵守了<code>Java虚拟机规范</code>中的约束。这个阶段一般不需要程序员参与。主要包含如下四部分：</p><ol><li>文件格式验证，比如文件是否以0xCAFEBABE开头，主次版本号是否满足当前Java虚拟机版本要求</li><li>元信息验证，例如类必须有父类(super不能为空)</li><li>验证程序执行指令的语义，比如方法内的指令执行中是否有跳转到不正确的位置</li><li>符号引用验证，例如是否访问了其他类中private的方法等</li></ol><div class="hint-container warning"><p class="hint-container-title">警告</p><p>编译文件的主版本号不能高于运行环境主版本号，如果主版本号相等，副版本号也不能超过</p></div><ul><li><strong>准备</strong></li></ul><p>准备阶段为静态变量(static)分配内存并设置初值，每一种基本数据类型和引用数据类型都有其初值</p><p>例如如下代码：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Student</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在准备阶段会为value分配内存并赋初值为0，在初始化阶段才会将值修改为1</p><div class="hint-container important"><p class="hint-container-title">重要</p><p>对于<code>final</code>修饰的变量，准备阶段直接将代码中的变量进行赋值，因为final的值不会改变</p></div><ul><li><strong>解析</strong></li></ul><p>解析阶段主要是将常量池中的<mark>符号引用</mark>替换为<mark>直接引用</mark>。我们知道，常量池中的所有内容都会有从1开始的编号，而符号引用就是在字节码文件中使用编号来访问常量池中的内容</p><h3 id="初始化阶段" tabindex="-1"><a class="header-anchor" href="#初始化阶段"><span>初始化阶段</span></a></h3><p>初始化阶段会执行字节码文件中<mark>clinit</mark>(class init 类的初始化)方法的字节码指令，包含了静态代码块中的代码，并为静态变量赋值</p><p>例如下面的代码：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Demo1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    static</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        value </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">   </span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> args</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应到字节码中，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/hxywd666/BlogResource/images/jvm3.png" alt=""></p><ul><li><code>&lt;init&gt;</code>是JVM为这个类提供的一个默认的构造函数<code>&lt;init&gt;()</code>，它在这个例子中没有展示在Java源码中但是存在于字节码中</li><li><code>main</code> 这是 Java 程序的入口点，<code>public static void main(String[] args)</code>方法会被直接编译为对应的字节码，且表示程序的主执行方法</li><li><code>&lt;clinit&gt;</code>对应的是Java源码中的静态代码块部分</li></ul><p>这里单独来看一下<code>&lt;clinit&gt;</code>方法中的字节码指令：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>iconst_1</span></span>
<span class="line"><span>putstatic #2</span></span>
<span class="line"><span>iconst_2</span></span>
<span class="line"><span>putstatic #2</span></span>
<span class="line"><span>return</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><code>iconst_1</code>：将常量1放入操作数栈。此时栈中只有1这个数</li><li><code>putstatic #2</code>：将操作数栈上的数弹出来，并放入堆中静态变量的位置，字节码指令中<code>#2</code>指向了常量池中的静态变量<code>value</code>，在解析阶段会被替换成<mark>变量的地址</mark></li><li>后两步操作类似，执行value=2，将堆上的value赋值为2</li></ol><div class="hint-container tip"><p class="hint-container-title">以下几种方式会导致类的初始化</p><ol><li>访问一个类的静态变量或者静态方法(注意变量是final修饰的并且等号右边是常量不会触发初始化)</li><li>调用Class.forName(String className)</li><li>new一个该类的对象时</li><li>执行Main方法的当前类</li></ol></div><div class="hint-container warning"><p class="hint-container-title">以下几种方式不会进行初始化指令</p><ol><li>无静态代码块且无静态变量赋值语句</li><li>有静态变量的声明，但是没有赋值语句 例如：<code>public static int a = 1</code></li><li>静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化</li></ol></div>`,71))])}const u=p(c,[["render",k],["__file","index.html.vue"]]),g=JSON.parse(`{"path":"/jvm/aa0nut89/","title":"字节码","lang":"zh-CN","frontmatter":{"title":"字节码","createTime":"2024/09/08 10:42:19","permalink":"/jvm/aa0nut89/","head":[["script",{"id":"check-dark-mode"},";(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if (um === 'dark' || (um !== 'light' && sm)) {document.documentElement.classList.add('dark');}})();"],["script",{"id":"check-mac-os"},"document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))"]]},"headers":[{"level":2,"title":"安装jclasslib","slug":"安装jclasslib","link":"#安装jclasslib","children":[]},{"level":2,"title":"组成","slug":"组成","link":"#组成","children":[{"level":3,"title":"魔数","slug":"魔数","link":"#魔数","children":[]},{"level":3,"title":"常量池","slug":"常量池","link":"#常量池","children":[]},{"level":3,"title":"字段","slug":"字段","link":"#字段","children":[]},{"level":3,"title":"方法","slug":"方法","link":"#方法","children":[]}]},{"level":2,"title":"类的生命周期","slug":"类的生命周期","link":"#类的生命周期","children":[{"level":3,"title":"加载阶段","slug":"加载阶段","link":"#加载阶段","children":[]},{"level":3,"title":"连接阶段","slug":"连接阶段","link":"#连接阶段","children":[]},{"level":3,"title":"初始化阶段","slug":"初始化阶段","link":"#初始化阶段","children":[]}]}],"readingTime":{"minutes":8.01,"words":2402},"git":{},"filePathRelative":"notes/JVM/基础篇/字节码.md"}`);export{u as comp,g as data};
